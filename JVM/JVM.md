# JVM

 JVM是Java运行基础,面试时一定会遇到JVM的有关问题,内容相对集中,但对只是深度要求较高.

最好重学一遍，因为这一块的笔记很乱，并且我了解的时候是在初学者的身份学的，所以学的很浅，只知道怎么回事。 --1.11



## 1、把你所能知道关于JVM的知识点说出来

- 线程独占：虚拟机栈，本地方法栈，程序计数器 
  线程共享：堆，方法区 （元空间）



- 堆
  
  - OOM的发源地，存储几乎所有的实例对象，
  
  - 可设置参数：Xmn（n=new，Eden和S1 S2），Xms，Xmx
  
  - 每个垃圾回收器默认的 Threashold 不同
  
    Parallel Scavenge：15
  
    CMS：6
  
    G1：15
  
  - 除了 Threashold 可以判断外，还有动态年龄判断，重新查阅
  
- 元空间

  - MetaSpace大小默认是无限的么? 
    
    MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。

  - 可以通过什么方式来指定大小?

    `-XX:MetaspaceSize`：分配给类元数据空间（以字节计）的初始大小。此值为估计值，设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。 

    `-XX:MaxMetaspaceSize`：分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。 

  - 版本不同

    - 1.7之前是PermGen

      在启动时固定大小，很难进行调优，并且FGC是会移动类元信息

      字符串常量在这里

    - 1.8之后是MateSpace

      元空间在本地内存中分配

      会FGC，字符串常量放在堆里

  - 类元信息（klass）

  - 方法表，保存着每个可以实例化类的方法信息，JVM可以通过方法表快速地激活实例方法。

- 虚拟机栈

  - 每个方法（就是一个栈帧）从开始调用到执行完成的过程，就是栈帧从入栈到出栈的过程。在线程活动中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。

  - **局部变量表**

    - 局部变量表是存放方法参数和局部变量的区域。

  - **操作栈**

    - 操作展示一个初始状态为空的桶式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。

    - JVM的执行引擎是基于栈的执行引擎，其中的栈值得就是操作栈。

    - 描述操作站与局部变量表的交互：

      ```java
      public int simpleMethod(){
          int x = 13;
          int y = 14;
          int z = x + y;
          
          return z;
      }
      ```

      局部变量表就像一个中药柜，很多抽屉编号为1、2、3、4、5、....、n。

      1. `BIPUSH 13`先将常量加载到操作栈中，并保存到局部变量表中`ISTORE_1`。
      2. `14`也是同样的操作
      3. 分别把在局部变量表中的两个元素压入操作栈中，`ILOAD_1`、`ILOAD_2`
      4. `IADD` 把上方的两个数都取出来，在CUP 里加一下，并压回到操作栈的栈顶。
      5. 栈顶的结果存储到局部变量表中`ISTORE_3`
      6. 再重新`ILOAD_3`
      7. `IRETURN` 返回栈顶元素值

      

    - 值得注意的a=i++ 和a=++i 操作中   iinc：

      **a = i++：**

      1. 把变量压入到操作栈栈顶
      2. 然后在抽屉里实现了+1的操作，而这个操作对在栈顶元素的值没有影响。所以只是把栈顶的值赋给了a。

      **a = ++i：**

      1. 在抽屉里 + 1了。所以不同

      延伸出一个信息，i++并不是原子操作。多个线程同时写的话，也会产生数据相互覆盖的问题。

    

  - **动态连接**

    每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态链接。

  - **方法返回地址**

    下面的看有点乱，马士兵说是，A() 里执行 B() 完成后，回到哪个地方。

    方法执行时有两种退出情况：
    
    - 第一，正常退出，即字节码指令：RETURN、IRETURN、ARETURN等
    - 第二，异常退出，无论何种退出情况，都将返回至方法当前被调用的位置。
    - 方法退出的过程相当于弹出当前栈帧，弹出可能有三种方式：
      - 返回值压入上层调用栈帧
      - 异常信息抛给能够处理的栈帧
      - PC计数器指向方法调用后的下一跳指令



- 本地方法栈
  - **为Native方法服务**
  - 线程开始调用本地方法时，会进入一个不在受JVM约束的区域。
  - 本地方法可以通过JNI（Java Native Interface）来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和JVM相同的能力和权限。
  - 如果大量的本地方法出现时，势必会削弱JVM对系统的控制力，因为它的出错信息都比较黑盒。
  - 内存不足的情况，本地方法栈还是会抛出natice heap OutOfMemory
  
  什么是JNI也可简单的说一下吗？
  
  - JNI类本地方法，其中最著名的本地方法应该是`System.currentTimeMillis()`，JNI使Java深度使用操作系统的特性功能，复用非Java代码。
  - 但是在项目过程中，如果大量的使用其他语言来实现JNI，就会丧失跨平台性，威胁到程序运行的稳定性。
    - 解决思想：添加中间框架进行解耦
  
  总结：执行Java方法是使用虚拟机栈，执行Native方法时使用本地方法栈。
  
- 程序技术寄存器
  
  - 每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。



## 2、Java源文件是如何转换成字节码的？

源文件经过词法解析，将形成token信息流，传递给语法解析器；语法解析器收到token信息流后，按照Java 语法规则组装成一颗语法树；之后在语义分析阶段，检查关键字的使用是否合理、类型是否匹配、作用域是否正确等；语义分析完成后，即可生成字节码。

总结：词法解析 -> 语法解析器 -> 组装成语法树 -> 语义分析 -> 字节码

字节码：

```
16进制
cafe babe 0000 0034  0014
   魔法值	小号 版本号 常量池内内容个数
```

可以写个简单的类练习一下。编译后打开class文件，可以用sublime，也可以用idea插件。根据马士兵的XMind去读16进制的的字节码。

往深点就是根据字节码进行java汇编，比如 (0x2a) aload_0，在 自己码中就是

## 3、字节码在JVM中经历了什么？

解释执行，JIT （JustInTime）编译执行

## 4、类加载过程

父加载器不是“ 类加载器的加载器 ”！也不是“ 类加载器的父类加载器 ”

复述书中的内容，够全

加载一类，从下往上询问是否加载过类，都查后发现自己的类加载器中并没有加载，然后就有要求子加载器此类。子加载器发现在自己里面并没有此class文件，那么就有向下推，直到加载上类。若找不到就抛出ClassNotFund

若想把一个类加载到内存中，调用对应的类加载器的 loadClass，返回一个 class 对象。也就是一层层的 findClass，找到就返回。

双亲委派模式：优点：

1. 避免类的重复加载 

2. 避免Java核心API被修改



## 5、怎么自定类加载器？

1. 继承`ClassLoader`

2. 重写`findClass()`方法

   源码中可以看到，protected 的 findClass 方法内只返回了一个ClassNotFund 异常，而需要重写补全功能。

   其中用到的是：模板方法。其他功能都实现了，就是中间部分需子类自己实现。

3. 调用方法中的`definClass()`方法。

   defineClass 最终把二进制流转换为 Class 类对象。

   ```java
   File f = new File(...);
   FileInputStream fis = new FileInputStream(f);
   ByteArrayOutStream baos = new ByteArrayoutStream();
   int b = 0;
   if (b = fis.read() != 0) {
       baos.write(b);
       byte[] bytes = baos.toByteArray();
       baos.close();
       fis.close();
   }
   return definClass(name, bytes, 0, bytes.length);
   
   mian(String[] args) {
       ClassLoader cl = new 刚定一个的类加载器();
       Class clazz = cl.getClass("全限定名");
       类名 test = (类名) clazz.getInstance();
       // 这样创建了一个 test对象，用到的是刚才自己创建的类加载器
   }
   
   ```

   

**插入一个不知道放哪里的 JVM 知识点**

## 缓存行（`caceh line`）

需要了解一下硬件层数据一致性，一致性的协议有很多种，因为 inter 用的是 MESI 协议，所以就了解这个即可。

`CPU`中每个缓存行（`caceh line`) 使用4种状态进行标记（使用额外的两位(`bit`)表示)

**MESI：**

- Modified	修改

  该缓存行只被缓存在该`CPU`的缓存中，并且是被修改过的，即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它`CPU`读取请主存中相应内存之前）写回主存。

  当被写回主存之后，该缓存行的状态会变成独享状态。

- Exclusive       独享

  该缓存行只被缓存在该`CPU`的缓存中，它是未被修改过的，与主存中数据一致。该状态可以在任何时刻当有其它`CPU`读取该内存时变成共享状态。

  同样地，当`CPU`修改该缓存行中内容时，该状态可以变成修改状态。

- Shared	  共享

  该状态意味着该缓存行可能被多个`CPU`缓存，并且各个缓存中的数据与主存数据一致，当有一个`CPU`修改该缓存行中，其它`CPU`中该缓存行可以被作废（变成无效状态）。

- Invalid         无效

  该缓存是无效的（可能有其它`CPU`修改了该缓存行）。



正式讲一下缓存行的问题：提交的时候是一块内存的提交，**通常是64个byte**。

举个例子：

- 现在有两个变量 a和b 要被提交。
- a和b 在被提交前放在同一小块内存中，也就是64个byte，进行提交。
- 这时候将 a 变量的 cpu 的那一条线程中内存 b 被修改了，那么这一块内存就被标为 Invalid，那么这一块内存就不得不回去重读一下获取新的值。但是 b 的修改与 a 变量的 cpu 无关，这么一来就浪费时间了。

改进方法：

```java
long p1, p2, p3, p4, p5, p6, p7;
long p8 = 1000;
long p1, p2, p3, p4, p5, p6, p7;
```

这么一来，p8无论是前边还是后边组合，都能合成独立的一块64字节的空间。



额外补充：

**1. 缓存行（Cache Line）的概念**

- **缓存行大小**：缓存（L1/L2/L3 Cache）是 CPU 和内存之间的一个高速缓存层，通常以 **缓存行（Cache Line）** 为最小单位进行数据传输。
  - 现代 CPU 的缓存行通常是 64 字节大小。

- **作用**：当 CPU 访问内存中的数据时，**它会把整条缓存行（64 字节）从内存加载到缓存**，即使只需要其中的 1 字节。这种设计是为了优化读取速度，减少访问内存的次数。

**2. CPU 一次可以处理多少数据？**

- **CPU 的位宽**决定了它每次能处理的数据量：

  - 64 位 CPU 一次能处理 **8 字节（64 位）** 数据。

  - 如果要处理完整的 64 字节数据，确实需要分成 **8 次处理**，每次处理 8 字节。

所以按照Java内的虚拟机来理解：就是每次在JVM的内存中取走64B的内容，加载到CPU那（L1/L2/L3 Cache）缓存中，而这个可称为一次取走的缓存行



## 6、对象实例化过程

用最简单的例子举例`Object obj = new Object();`

字节码角度看：

- 通过javap -verbose -p命令可以看到对象创建的字节码

  ```java
  stact=2, locals=1, args_size=0
      NEW java/lang/Object
      DUP
      INVOKESPECIAL java/lang/Object.<init> ()V
      ASTORE_1
      LocalVariableTable:
  		Start	Length	Slot	Name	Signature
            8		   1	 0		 obj	Ljava/lang/Object
  ```

- NEW：如果找不到Class对象，则进行类加载。加载成功后，则在队中分配内存，从Object开始到本类路径上的所有属性值都要分配内存。==在分配过程中，注意 引用是占据存储空间的，他是一个变量，占用4个字节。==

  ```
  refvar(Reference Variable)在面向对象世界中称为引用变量，或者叫引用句柄。是基本数据类型，默认值null
  把引用对象指向 实际对象(Refered Object) 简称refobj。
  ```

- 指令完毕后，将指向实例对象的引用变量压入虚拟机栈顶。

- DUP：在栈顶复制该引用变量，这是的栈顶的两个指向堆内实例对象的引用变量。两个引用变量的目的不同，其中压在底下的用于**赋值**，或者保存到局部变量表，另一个栈顶的引用变量作为**句柄**调用相关方法。

- INVOKESPECIAL：调用对象实例方法，通过栈顶的引用变量调用< init >方法。
  < clinit > 是类初始化执行的方法，而< init > 是对象初始化时执行的方法。

执行步骤角度来分析：

- 确认元信息是否存在

  在JVM 接收到new 的指令时，首先会在元空间（Metaspace）内检查需要创建的 类元信息 是否存在。
  如果不存在，那么在双亲委派模式下，使用当前类加载器，以 ClassLoader + 包名 + 类名 为Key 进行查找对应的.class文件。
  如果没有找到，则抛出`ClassNoFoundException`异常。
  如果找到，则进行类加载，并生成对应的Class类对象。

- 分配对象内存

  首先计算对象占用空间大小，如果实例成员变量是引用变量，仅分配引用变量空间即可，接着在堆中划分一块内存给新对象。
  在分配内存空间时，需要进行同步操作，比如采用CAS（Compare And Swap）失败重试、区域加锁等方式保证分配操作的原子性。

- 设定默认值

  成员变量值都是需要设定为默认值，即各种不同形式的零值。

- 设置对象头

  设置型对象的哈希码、GC信息、锁信息、对象所属的 类元信息 等。这个过程具体设置方式取决于JVM 实现。

- 执行 init 方法

  初始化成员变量，执行实例化代码块，调用类的构造方法，并把对内对象的首地址赋值给引用变量。

这里就有另外一个问题，就是会有重排问题，比如：分配内存 和 执行init 上下颠倒



## 7、简述Java的对象结构（存储布局）

三部分组成：对象头、实例数据、对齐填充

然后就把这些知识点复述一遍





## 8、如何判断对象可以被回收的

- 根据GC Roots判断。

  如果一个对象与GC Roots 之间没有直接或间接的引用的引用关系

  - 比如某个失去任何引用的对象，或者两个互相环岛状循环引用的对象等，判断这些对象可被回收

- 什么对象可以作为GC Roots？

  - 类静态属性中引用的对象
  - 常量引用的对象
  - 虚拟机栈中引用的对象
  - 本地方法栈中引用的对象





## 9、垃圾回收的相关算法

- 最基础的“ 标记 - 清除算法 “ ：

  - 两遍扫描，在存活对象比较多的时候有效。
  - 该算法从每个GC Roots出发，依次标记有引用关系的对象，最后将没有被标记的对象清除。
  - 但这种算法会带来大量的空间碎片，导致需要分配一个较大连续空间时容易出发FGC。

- ” 标记 - 整理算法 ”：

  - 两遍扫描
  - 该算法类似计算机磁盘整理
  - 从GC Roots出发标记存活的对象，然后将存活对象整理到内容空间一端，形成连续的已使用空间，最后把已使用空间外的部分全部清除，这样就不会产生空间碎片的问题。

- “ Mark-Copy ”：

  堆中的一个回收方式

  现在作为主流的YGC算法进行新生代的垃圾回收

  这样一来还得重新给复制好的对象引用

- 分代搜集算法：

  根据各个年代的特点采用最适当的收集算法



先写进来，还不太理解

JVM 内存分代模型（用于垃圾回收算法）

- 部分垃圾回收器使用

  除 Epsilon、ZGC、shanandoah 之外的 GC，都是使用逻辑分代模型，G1是逻辑分代模型，物理不分代。除此之外不仅逻辑分代，且物理分代。



## 10、垃圾回收器

Serial、Serial Old、CMS、ParNew、Parallel Scavenge、Parallel Old、G1、ZGC、Shanandoah、Epsilon

常见三种组合：

1. Serial、Serial Old

2. Parallel Scavenge、Parallel Old 简称 PS + PO 没指定，默认开启

3. CMS、ParNew

   

“Stop The World”：简称STW，即垃圾回收的某个阶段会暂停整个应用程序的执行，当然不是直接停止，线程会找到safe point上停止。

FGC时触发的时间 STW 相对较长，频繁的FGC会严重影响应用程序的性能。

举例：

- 10G 内存用 PS + PO 来清：87W 耗十几秒
- CMS 到最后因为碎片问题触发的 FGC 长达十几小时



主讲Serial、CMS、G1三种。

- **Serial**：主要应用于YGC的垃圾回收器，采用串行单线程的方式完成GC任务。

- **CMS：**（Concurrent Mark Sweep Collector）是回收停顿时间比较短、目前比较常用的垃圾回收器

  通过：

  1. 初始标记（Initial Mark）
  2. 并发标记（Consurrent Mark）会很耗时
  3. 重新标记（Remark）STW时间较短，因为2操作
  4. 并发清除（Concurrent Sweep）

  四个步骤完成垃圾回收工作。

  - 第1、3步骤的依然会引发STW
  - 而2、4步骤可以和应用程序并发执行，也是比较耗时的操作，但不影响程序的正常执行。

  由于“CMS”是“标记-清除算法”，随意会**产生大量的空间碎片**。

  - 解决方法：可通过配置`-XX:+UseCMSCompactAtFullCollection`，强制JVM在FGC完成后对老年代进行压缩，执行一次空间碎片整理，但空间碎片整理阶段也会引发STW。
    - 再解决：减少STW的次数，CMS还可以通过配置`-XX:+CMSFullGCsBeforeCompactioin=n`参数，在执行n次FGC后，JVM再在老年代执行空间碎片整理。

  在最后并发清除的阶段，又产生了新的垃圾，被称为“ 浮动垃圾 ”，CMS + Serial Old 又是组合。出现：

  - 问题1：当 CMS 到后期不能动弹时候，Serial Old 这个单线程垃圾回收器，拿着扫把慢慢悠悠的扫天安门前的垃圾 

  - 问题2：并发清除期间新生成的浮动垃圾快塞满了Old，这时Servious 那边又来新对象塞不下了，就会请Serial Old 单线程老祖宗慢慢清理，清理期间会触发STW。这就是`PromotionFailed`晋升失败问题，

    解决方法：降低触发CMS的阈值，参数：-XX:CMSInitiatingOccupancyFraction 92% 把92降到50，60就可以。



- **G1：**HotSpot在JDK7 中推出了新一代G1（Garbage-First Garbage Collector）垃圾回收。

  - 采用“Mark-Copy”，非常好的空间整理能力，不会产生大量的空间碎片。

  - 通过`-XX:+UseG1GC`参数启动。

  - 与CMS相比，G1具备压缩用能，能避免面碎片问题，G1的暂停时间更加可控。

  - 运行原理：

    - G1将Java堆空间分割成了若干相同大小的区域，即region，包括Eden、Survivor、Old、Humongous（是特俗的Old类型，专门存放大型对象）四种类型。
    - 这样的划分方式意味着不需要一个连续的内存空间管理对象。
    - 优势：可预测停顿时间，能够尽可能快地在指定时间内完成垃圾回收任务。

  - 在JDK11，将G1设为默认垃圾回收器。

    



## 11、你知道哪些JVM性能调优命令

Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo

1. jps：显示指定系统内所有的HotSpot虚拟机进程。 
2. jstat：用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机 进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 
3. jmap：JVM Memory Map命令用于生成heap dump文件
4. jhat：是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了 一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 
5. jstack：生成java虚拟机当前时刻的线程快照
6. jinfo：实时查看和调整虚拟机运行参数



- 设置堆内存大小`-Xms  -Xmx`，设置成一样大小，避免在GC后调整堆大小时带来的额外压力。
- 设置新生代大小，如果太小，那么会有大量的对象涌入老年区。





## 12、简述Java垃圾回收机制

在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一 个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不 足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收



## 13、什么时候会触发FullGC

JVM内存不够的时候发生FGC 

1. 老年代空间不足
2.  CMS GC时出现promotion failed和concurrent mode failure
   - `promotionfailed`是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的
   - concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的
3.  统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间





## 14、如何启动系统的时候设置JVM的启动参数

其实很简单，比如采用“Java -jar”的方式启动一个jar包里的系统，那么就可以采用类似下面那的格式

`java -Xms512M -Xmx512M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar`





## 15、调优 JVM

-X:printGC



## 16、说说你所知道的几种参数





1. DCL需不需要volatile

   



