# MySQL

## 1、数据库的三范式是什么 

1. 第一范式（1NF）：（列不可分）字段具有原子性,不可再分。(所有关系型数据库系 统都满足第一范式数据库表中的字段都是单一属性的，不可再分) 
2. 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，**即满足 第二范式（2NF）必须先满足第一范式（1NF）**。要求数据库表中的每个 实例或行 必须可以被唯一区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个唯一属性列被称为主关键字或`主键`。（不能存在传递依赖）
3. 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 
   - 所以第三范式具有如下特征： 
     1. 每一列只有一个值（字段原子性，不可再拆分）
     2. 每一行都能区分（主键）
     3. 每一个表都不包含其他表已经包含的非主关键字信息（不要消息重复）

## 2、数据库引擎有哪些 

如何查看mysql提供的所有存储引擎？

`mysql> show engines`

mysql常用引擎包括：MYISAM、Innodb、Memory、MERGE

- MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎 
- Innodb：行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些 
- Memory：全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变化不频繁的代码表 
- MERGE：是一组MYISAM表的组合 





## 4、数据库的事务 

**什么是事务？**： 多条sql语句，要么全部成功，要么全部失败。 

**事务的特性：**
**数据库事务特性：原子性(Atomic)、一致性(Consistency)、隔离性(Isolation)、持久性(Durabiliy)。 简称ACID。**

- 原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。
-  一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如 A 转账100元给 B，不管操作是否成功，A 和 B 的账户总额是不变的。 
- 隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰 
- 持久性：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中

事务隔离级别



## 5、索引问题 

> 索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。 

你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 

`mysql `有4种不同的索引：

- 主键索引（PRIMARY） 

  数据列不允许重复，不允许为NULL，一个表只能有一个主键。 

- 唯一索引（UNIQUE） 

  数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。 

  - 创建唯一索引     ` ALTER TABLE table_name ADD UNIQUE (column); ` 
  - 创建唯一组合索引  `ALTER TABLE table_name ADD UNIQUE (column1,column2); ` 

- 普通索引（INDEX） 
  - 创建普通索引     `ALTER TABLE table_name ADD INDEX index_name (column);`  
  - 创建组合索引     `ALTER TABLE table_name ADD INDEX index_name (column1, column2, column3);` 

- 全文索引（FULLTEXT） 

  - 创建全文索引     `ALTER TABLE table_name ADD FULLTEXT (column);`  



 **索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时 要花费较多的时间维护索引**

- 索引加快数据库的检索速度 
- 索引降低了插入、删除、修改等维护任务的速度 
- 唯一索引可以确保每一行数据的唯一性 
- 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能 
- 索引需要占物理和数据空间 



## 6、SQL优化 

1. 查询语句中不要使用select * ，统计用count(1)

2. 尽量减少子查询，使用关联查询（left join, right join, inner join）替代

3. 减少使用IN或者NOT IN，使用exists，not exists或者关联查询语句替代 

4. or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好) 

5. 放弃使用索引行为：

   1. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎==放弃使用索引==而进行全表扫描。

   2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎==放弃使用索引==而进行全表扫描，
      如： `select id from t where num is null` 

      可以在 num 上设置默认值0，确保表中 num 列没有 null 值，然后这样查询： `select id from t where num=0` 

   3. **前导模糊查询不会使用索引**（%李）

   4. **小心隐式类型转换**都会导致==放弃使用索引==

6. 除此之外还有**不要在索引列上进行运算或使用函数**（id+1=5）



关联查询优化

- **优先选择INNER JOIN**：当业务逻辑允许时，效率通常更高。

- **索引**：为联接条件字段（如外键）添加索引，可显著提升所有联接类型的效率。
- **业务需求优先**：若需保留左表全部数据，必须用`LEFT JOIN`，不可为效率牺牲正确性。
- **简化查询**：避免在`LEFT JOIN`后通过`WHERE`过滤右表数据（可能导致优化器误判），可改用`INNER JOIN`。

```sql
-- 高效：INNER JOIN + 索引
SELECT a.*, b.*
FROM table_a a
INNER JOIN table_b b ON a.id = b.a_id;  -- 假设a.id和b.a_id均有索引

-- 需谨慎：LEFT JOIN + 无索引
SELECT a.*, b.*
FROM table_a a
LEFT JOIN table_b b ON a.id = b.a_id;   -- 若b.a_id无索引，可能全表扫描
```













## 7、drop、delete与truncate的区别 

- SQL中的drop、delete、truncate都表示删除，但是三者有一些差别 

- delete 和 truncate 只删除表的数据不删除表的结构 

- 速度，一般来说: drop > truncate > delete 

- delete语句是DML，这个操作会放到rollback segement中，事务提交之后才生效; 

- 如果有相应的trigger，执行的时候将被触发。truncate, drop是DDL，操作立即生效，原数据不放到rollback segment中，不能回滚。操作不触发trigger。

GPT详情内容：

- DROP TABLE 和 TRUNCATE TABLE 都会记录在 binlog 中，但不会记录到 redo log 和 undo log。

  在binlog中记录：

  - DROP TABLE 记录的是 **删除表** 的操作。

  - TRUNCATE TABLE 记录的是 **删除表后重新创建** 的操作（相当于 DROP TABLE + CREATE TABLE）。

  不再redo log记录的原因：

  - 因为 DROP TABLE 和 TRUNCATE TABLE 这些操作 **不会涉及对单个行数据的变更**，而是直接修改表元数据（对 sys_tables、sys_columns 等元数据表进行变更）。

  - TRUNCATE TABLE 本质上是 **先删除表，再重新创建**，不像 DELETE 那样逐行删除数据，因此不会记录 redo log。

| **操作**       | **binlog（用于复制和恢复）** | **redo log（用于崩溃恢复）** | **undo log（用于事务回滚）** |
| -------------- | ---------------------------- | ---------------------------- | ---------------------------- |
| DROP TABLE     | ✅ 记录操作                   | ❌ 不记录                     | ❌ 不记录                     |
| TRUNCATE TABLE | ✅ 记录操作                   | ❌ 不记录                     | ❌ 不记录                     |
| DELETE         | ✅ 记录操作                   | ✅ 记录操作                   | ✅ 记录（支持回滚）           |



## 8、什么是视图？

- **视图 (View)** 是基于一张或多张表的查询结果创建的虚拟表。

- 它并不存储实际数据，而是保存了查询逻辑，数据来自于它引用的基础表（即视图的源表）。

**通过视图修改数据的影响**

1. **修改视图数据是否会影响源表？**

   **答案是：可能会影响源表数据**，但取决于以下条件：

   - **视图是否可更新**：只有可更新视图支持数据修改，并将操作反映到源表。
   - 可更新的视图：满足一定条件（如没有聚合、分组、函数等）。
   - 不可更新的视图：如包含 GROUP BY、DISTINCT、JOIN、子查询 等复杂逻辑，视图本身不能进行数据修改。
   - **操作权限**：数据库用户是否具有对视图和其源表的写权限。

2. **视图上的操作如何影响源表？**

   如果视图是可更新的，且你对视图进行了 INSERT、UPDATE 或 DELETE 操作，这些操作将直接影响源表中的数据。例如：

   ```sql
   CREATE VIEW my_view AS SELECT id, name FROM employees WHERE department = 'Sales';
   
   -- 修改视图数据
   UPDATE my_view SET name = 'John' WHERE id = 1;
   -- 实际上是修改了 employees 表中的数据
   ```

3. **不可更新视图的特点**

   以下情况会导致视图不可更新：

   - 使用了聚合函数（如 SUM、AVG 等）。
   - 包含 GROUP BY 或 DISTINCT。
   - 引用了多个表且无法确定更新目标。
   - 使用了 UNION 或 UNION ALL。
   - 包含子查询。
   - 使用了计算列（如 price * quantity）。

   这些情况下，即使你尝试修改视图，也不会生效。

---

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图**通常是有一个表或者多个表的行或列的子集**。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

虚拟的表和普通的表一样，通过普通的表动生成的数据，只保存sql逻辑，不保存查询结果

sql语句 

```sql
# 视图的修改
create or replace view 别名 as 
# 删除视图
drop view 视图名1，视图名2
# 查看视图
desc 视图名 show create view 视图
```

常量视图（只有一个结果）？



- #### 两者区别

| **特性**       | **视图 (View)**                                              | **表 (Table)**                                             |
| :------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| **存储数据**   | 不存储实际数据，仅存储查询逻辑，数据来自源表                 | 存储实际数据，数据保存在磁盘中                             |
| **创建方式**   | 通过 `CREATE VIEW` 创建，基于查询结果生成                    | 通过 `CREATE TABLE` 创建，直接定义表结构和字段             |
| **数据更新**   | 仅可更新可更新视图，修改时会影响源表数据                     | 可直接插入、更新或删除数据，影响表本身的数据               |
| **物理存在**   | **逻辑存在，不占用实际存储空间**                             | 物理存在，占用磁盘存储空间                                 |
| **使用场景**   | 用于简化复杂查询、提高查询复用性或限制访问权限               | 用于存储和管理数据，作为数据库的核心存储单位               |
| **依赖关系**   | 依赖于源表，源表发生变化（如删除字段）可能导致视图失效       | 独立存在，不依赖于其他表                                   |
| **性能**       | 查询时从源表动态生成结果，性能受视图复杂度和源表数据量影响   | 直接读取存储的数据，性能更高                               |
| **更新限制**   | 有一定限制，仅支持更新可更新视图                             | 可自由更新数据，无限制                                     |
| **安全性**     | 可用于隐藏源表的部分字段或行，提高数据访问安全性             | 源表本身无法隐藏部分数据，需配合权限控制                   |
| **数据独立性** | 数据来自源表，源表的数据变化会实时反映到视图中               | 表中的数据独立存在，数据变化仅影响自身                     |
| **支持的操作** | 支持查询（`SELECT`），部分视图支持更新（`INSERT`、`UPDATE`、`DELETE`） | 支持所有数据操作（`SELECT`、`INSERT`、`UPDATE`、`DELETE`） |
| **删除的影响** | 删除视图不会影响源表的数据                                   | 删除表会导致数据丢失                                       |





## 9、 什么是内联接、左外联接、右外联接？

- 内联接（Inner Join）：匹配2张表中相关联的记录。 
- 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录， 右表中未匹配到的字段用NULL表示。 
- 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录， 左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join的左右 位置关系









## 10、并发事务带来哪些问题？

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一 数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）**: 当一个事务正在访问数据并且对数据进行了修改，而这种修改`还没有提交到`数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确 的。 

- **丢失修改（Lost to modify）**: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 

  例如：事务1读取某表中的数据A=20，事务2也读取A=20，事 务1修改A=A-1，事务2也修改A=A-1，终结果A=19，事务1的修改被丢失。 

- **不可重复读（Unrepeatableread）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改 导致第一个事务两次读取的数据可能不一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 

- **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。



**不可重复读和幻读区别：**修改和删除





## 11、事务隔离级别有哪些? MySQL的默认隔离级别是?

**SQL 标准定义了四个隔离级别：** 

- **READ-UNCOMMITTED(读取未提交)：** 低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读。** 

- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生。** 

- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。** 

  **关于幻读**（新）：

  - 在 MySQL 的 InnoDB 引擎中，REPEATABLE-READ 使用了 MVCC 和间隙锁（Next-Key Lock），在大多数场景下能够避免幻读。

  - 理论上，REPEATABLE-READ 不解决幻读，但 MySQL 中实现了避免幻读的机制。

- **SERIALIZABLE(可串行化)：** 高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执 行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读。**



| 隔离级别         | 脏读 | 不可重复读 | 幻读                                |
| ---------------- | ---- | ---------- | ----------------------------------- |
| READ-UNCOMMITTED | √    | √          | √                                   |
| READ-COMMITTED   | ×    | √          | √                                   |
| REPEATABLE-READ  | ×    | ×          | **×（MySQL 默认情况下避免了幻读）** |
| SERIALIZABLE     | ×    | ×          | ×                                   |

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过 `SELECT @@tx_isolation;` 命令来查看 

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READCOMMITTED(读取提交内容)** ，InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）** 并不会有任何性能损失。 

InnoDB 存储引擎在分布式事务 的情况下一般会用到 **SERIALIZABLE(可串行化)** 隔离级别。



## 12、大表如何优化？

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下： 

**1.限定数据的范围** 

**禁止**不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内； 

**2. 读/写分离** 

经典的数据库拆分方案，主库负责写，从库负责读； 

**3. 垂直分区** 

**根据数据库里面数据表的相关性进行拆分。**  例如，用户表中既有用户的登录信息又有用户的基本信息， 可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 

- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的 Block 数，减少 I/O次 数。此外，垂 直分区可以简化表的结构，易于维护。 
- **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行 Join 来解决。此外，垂直分区会让事务变得更加复杂； 



**4. 水平分区** 问GPT

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成 多张表来存放。




## 13、分库分表之后,id 主键如何处理？

因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来 支持。

生成全局 id 有下面这几种方式：

- **UUID：**不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。
- **数据库自增 id :**  两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成 的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。 
- **利用 redis 生成 id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更 加复杂，可用性降低，编码更加复杂，增加了系统成本。

- **Twitter的snowﬂake算法 ：**Github 地址：https://github.com/twitter-archive/snowﬂake。 
- **美团的Leaf分布式ID生成系统 ：**Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、 Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/04/21/mt-leaf.html 。 



## 14、mysql有关权限的表都有哪几个 

MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由 mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分 别介绍一下这些表的结构和内容：

- user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。 
- db权限表：记录各个帐号在各个数据库上的操作权限。
- table_priv权限表：记录数据表级的操作权限。 
- columns_priv权限表：记录数据列级的操作权限。 
- host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受 GRANT和REVOKE语句的影响。 



## 15、创建索引的三种方式，删除索引 

第一种方式：在执行CREATE TABLE时创建索引

第二种方式：使用ALTER TABLE命令去增加索引 

第三种方式：使用CREATE INDEX命令创建

删除索引
根据索引名删除普通索引、唯一索引、全文索引： `alter table 表名 drop KEY 索引名`

删除主键索引： `alter table 表名 drop primary key `（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）： 

```sql
alter table t_user drop primary key
```

 需要取消自增长再行删除：  

```sql
alter table t_user
-- 重新定义字段 
MODIFY id int, 
drop PRIMARY KEY
```

 但通常不会删除主键，因为设计主键一定与业务逻辑无关。 









