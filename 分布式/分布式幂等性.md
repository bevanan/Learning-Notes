# 分布式幂等性

## 分布式幂等性的设计

需要进行幂等性的场景

前端页面点击提交，避免由于网络原因或者其他STW情况，引发的多次提交。

像增删改查中，删和查的情况不需要幂等性。

增，可以增加唯一索引，报错提示幂等性

改，1. mysql互斥for update，2. redis的分布式锁setnx



### 1.分布式幂等性如何设计？

在高并发场景的架构里，幂等性是必须得保证的。比如说支付功能，用户发起支付，如果后台没有做幂等校验，刚好用户手抖多点了几下，于是后台就可能多次受到同一个订单请求，不做幂等很容易就让用户重复支付了，这样用户是肯定不能忍的。

解决方案：

1. 查询和删除不在幂等讨论范围，查询肯定没有幂等的说，删除：第一次删除成功后，后面来删除直接返回0，也是返回成功。

2. 建唯一索引：唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增异常时，再查询一次就可以了，数据应该已经存在了，返回结果即可）。

3. token机制：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交。前端在数据提交前要向后端服务的申请token，token放到 Redis 或 JVM 内存，token有效时间。提交后后台校验token，同时删除token，生成新的token返回。redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用。

4. 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用（另外还要考虑id是否为主键，如果id不是主键或者不是 InnoDB 存储引擎，那么就会出现锁全表）。for update

5. 乐观锁，给数据库表增加一个version字段，可以通过这个字段来判断是否已经被修改了

6. 分布式锁，比如 Redis 、 Zookeeper 的分布式锁。单号为key，然后给Key设置有效期（防止支付失败后，锁一直不释放），来一个请求使用订单号生成一把锁，业务代码执行完成后再释放锁。

7. 保底方案，先查询是否存在此单，不存在进行支付，存在就直接返回支付结果。





## 分布式事务

### CAP定理

分布式存储系统的CAP原理（分布式系统的三个指标）：

1. **C**onsistency（一致性）：在分布式系统中的所有数据备份，在**同一时刻是否同样的值**。

   对于数据分布在不同节点上的数据来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。

2. **A**vailability（可用性）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（要求数据需要备份）

3. **P**artition tolerance（分区容忍性）：大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。

&emsp;&emsp;CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以**分区容忍性是我们无法避免的**（换句话说如果去除P那就是单机了）。所以我们只能在一致性和可用性之间进行权衡，没有系统能同时保证这三点。要么选择CP、要么选择AP。

### BASE定理

&emsp;&emsp;BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。接下来看看BASE中的三要素：

1. Basically Available（**基本可用**）

   基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。
   电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。

2. Soft state（软状态）

   软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，**允许不同节点间副本同步的延时**就是软状态的体现。mysql replication的异步复制也是一种体现。

3. Eventually consistent（最终一致性）

   最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。

BASE模型是传统ACID模型的反面，不同于ACID，BASE强调牺牲高一致性，从而获得可用性，数据**允许在一段时间内的不一致，只要保证最终一致就可以了**。



### 解决方案：

#### 一致性分类

1. **强一致性**
   - 事务操作完成后，所有节点数据实时一致（如银行转账）。
   - 典型方案：**2PC、XA 协议、TCC（部分实现）**。
2. **最终一致性**
   - 允许短暂不一致，通过异步补偿或重试最终达到一致。
   - 典型方案：**消息队列、Saga、最大努力通知、Seata（AT模式默认）**。



#### 解决方案对比表

|          方案          |  一致性  |                           原理                          |         优点         |              缺点             |           适用场景            |
| :------------------------: | :----------: | :----------------------------------------------------------: | :----------------------: | :--------------------------------: | :-------------------------------: |
|   2PC（两阶段提交）    |   强一致性   |    协调者分两阶段（Prepare/Commit）协调参与者提交或回滚。    | 强一致，适合数据库层事务 |     同步阻塞、单点故障、性能低     |        传统金融、跨库事务         |
|        XA 协议         |   强一致性   |                数据库层基于 XA 接口实现 2PC。                |      强一致，标准化      |       依赖数据库支持，性能差       |    银行系统、数据库跨节点事务     |
|      TCC 补偿事务      | 强/最终一致  | Try（预留资源）- Confirm（提交）- Cancel（回滚），需开发者实现补偿逻辑。 |    灵活，适合复杂业务    |       代码侵入性高，设计复杂       |        电商库存、资金扣减         |
|  消息队列+本地事件表   |  最终一致性  |     本地事务与消息写入原子操作，消费者重试保证最终一致。     |       解耦、高可用       | 需维护本地消息表，存在重复消费风险 |      订单状态更新、异步通知       |
| 事务消息（如RocketMQ） |  最终一致性  |      消息队列提供事务消息机制（半消息+本地事务检查）。       |   无需本地表，简化流程   |          依赖消息队列特性          |     高并发场景（如秒杀订单）      |
|    Seata（AT模式）     | 默认最终一致 |       通过全局锁+回滚日志（undo_log）自动提交或回滚。        |  低侵入性，适合简单业务  |       全局锁可能引发性能瓶颈       |   普通分布式事务（如订单+库存）   |
|    Seata（TCC模式）    | 强/最终一致  |                  手动实现 TCC 三阶段接口。                   |     灵活控制事务边界     |            代码侵入性高            | 复杂业务（如积分+优惠券组合操作） |
|   Seata（Saga模式）    |  最终一致性  |          通过状态机编排事务链，失败时触发反向补偿。          |        适合长事务        |  需定义补偿逻辑，可能遗留中间状态  |     物流跟踪、多服务协作流程      |
|      最大努力通知      |  最终一致性  |              周期性重试通知，直到对方确认成功。              |         实现简单         |    不保证绝对一致，依赖重试机制    |      支付结果回调、短信通知       |
|       Saga 模式        |  最终一致性  |       通过事件编排或编排器管理事务链，失败时反向补偿。       |      适合长周期事务      |            补偿逻辑复杂            |      电商订单、跨境支付流程       |



#### 如何选择？

1. **强一致性场景**：
   - 要求实时一致（如转账、库存扣减）。
   - 选 **2PC/XA、TCC、Seata（TCC模式）**。
2. **最终一致性场景**：
   - 允许短暂不一致（如订单状态、异步通知）。
   - 选 **消息队列、Saga、最大努力通知、Seata（AT/Saga模式）**。
3. **长事务场景**：
   - 流程复杂且耗时长（如电商下单）。
   - 选 **Saga 模式、Seata（Saga模式）**。





## 分布式锁

redis部分及是学习部分的中的那些




